<!DOCTYPE html>
<!-- saved from url=(0066)file:///C:/Users/YuYang/AppData/Local/Temp/MarkdownPadPreview.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>reference_manual</title>

<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<!--<base href="file:\\\D:\Bham\Y4\Final_Year_Project\ProofChecker\">--><base href=".">
</head>
<body>
<p>Title:  Proof Checker Reference Manual<br>
Author: Yu-Yang Lin<br>
Date:   22 August, 2015  
</p>
<h1>Proof Checker Reference Manual</h1>
<h5><code>version: 0.9.0.0</code></h5>
<h2>Table of Contents</h2>
<ul>
<li><a href="reference_manual.html#section1">Introduction</a></li>
<li>
<a href="reference_manual.html#section2">Usage</a>
<ul>
<li><a href="reference_manual.html#section2.1">Compiling</a></li>
<li><a href="reference_manual.html#section2.2">Compiling on Windows Machines</a></li>
<li><a href="reference_manual.html#section2.3">Using the tool</a></li>
</ul>
</li>
<li>
<a href="reference_manual.html#section3">The Proof Language</a>
<ul>
<li>
<a href="reference_manual.html#section3.1">Keywords and Lexical Conventions</a>
<ul>
<li><a href="reference_manual.html#section3.1.1">Types</a></li>
<li><a href="reference_manual.html#section3.1.2">Terms</a></li>
<li><a href="reference_manual.html#section3.1.3">Propositions</a></li>
<li><a href="reference_manual.html#section3.1.4">Proofs</a></li>
<li><a href="reference_manual.html#section3.1.5">Top-Level</a></li>
</ul>
</li>
<li><a href="reference_manual.html#section3.2">Organisation of Proof Files</a></li>
</ul>
</li>
<li>
<a href="reference_manual.html#section4">Examples</a>
<ul>
<li><a href="reference_manual.html#section4.1">Law of Excluded Middle</a></li>
<li><a href="reference_manual.html#section4.2">Involution of Reversing a List</a> </li>
</ul>
</li>
</ul>
<p><a name="section1"></a></p>
<h2>Introduction</h2>
<p>The Proof Checker is a command-line tool made to validate simple program-correctness proofs of functional programs using inductive and equational reasoning. By necessity, the checker was also made to deal with propositional logic.</p>
<p>The tool source is written in <strong>OCaml</strong>, using OCamllex and <a href="http://gallium.inria.fr/~fpottier/menhir/">Menhir</a> for the parser, and was developed on a Windows machine. Proofs are validated through sequent calculus rules. Specifications for the rules can be seen in the <a href="reference_manual.htmlnotes.pdf">notes</a>.</p>
<p><a name="section2"></a></p>
<h2>Usage</h2>
<p><a name="section2.1"></a></p>
<h3>Compiling</h3>
<p>To use the tool, it must first be compiled. For this, use <code>src\Makefile</code> provided. The compiled tool will be named <code>proof_checker.exe</code> by default. </p>
<p>Requirements for compilation are:</p>
<ul>
<li>GNU Make</li>
<li>Menhir </li>
<li>OCamllex</li>
<li>OCaml Batch Compiler (<code>ocamlc</code>)</li>
</ul>
<p><a name="section2.2"></a></p>
<h3>Compiling on Windows Machines</h3>
<p>Windows users can find the Menhir package <code>godi-menhir</code> in <a href="http://wodi.forge.ocamlcore.org/">WODI</a>, the Windows version of the package manager GODI. I recommed this over OPAM since I couldn't get OPAM working.</p>
<p>You can compile the tool from Cygwin. I used <a href="http://gnuwin32.sourceforge.net/packages/make.htm">make for Windows</a> found in the GnuWin32 files page, and compile the tool from <strong>Windows PowerShell</strong>.</p>
<p><a name="section2.3"></a></p>
<h3>Using the tool</h3>
<p>To use the tool, run <code>proof_checker.exe</code> from a command-line console on a target proof file. By default, the extension for proof files is <code>.proof</code>.</p>
<p>e.g.</p>
<pre><code>.\proof_checker.exe "testing\test_proof.proof"
</code></pre>

<p>This should output a success message if the proof is valid, or output an error message with position data for where the checker failed.</p>
<p>For instance, a successful proof would output:</p>
<pre><code>  ***Opening file: ..\extra\sample_proofs\rev_involution.proof.....[done]***
  ***Lexing and Parsing file..........[done]***
  ***Checking file....................[done]***
  ***VALIDATION SUCCESSFUL****
</code></pre>

<p>While a failed proof might output:</p>
<pre><code>  ***Opening file: ..\extra\sample_proofs\rev_involution.proof.....[done]***
  ***Lexing and Parsing file..........[done]***
  ***Checking file....................[error]***
  [VALIDATION FAILURE]:
Expected hypothesis for 't=t:(nat) list' but
'[rev xs]' points to proposition
'(forall xs : (nat) list . (forall x : nat . ((rev x :: xs) = 
 ((append (rev xs)) x :: nil) : (nat) list)))'.
Encountered while evaluating 'by equality' clause.
Encountered while evaluating 'by induction on list'.
  (line 106 , col 12) to (line 106 , col 34)
</code></pre>

<p>Syntax for proof files can be seen in the sample proofs provided, you can find the proofs under <a href="file:///D:/extra/sample_proofs">extra/sample_proofs</a>.</p>
<p><a name="section3"></a></p>
<h2>The Proof Language</h2>
<p>The Proof Checker uses a language designed to look like a hand-written proof in English. It won't always be grammatically correct English, however.</p>
<p><a name="section3.1"></a></p>
<h3>Keywords and Lexical Conventions</h3>
<p>Proofs contain several data type categories which separate the proof files into different hierarchical layers. Organisation of proof files will be explained later on.</p>
<p><a name="section3.1.1"></a></p>
<h4>Types</h4>
<p>This data type contains the type of terms.</p>
<ul>
<li><strong>Booleans</strong>: <code>bool</code></li>
<li><strong>Natural Numbers</strong>: <code>nat</code></li>
<li><strong>Type Variables</strong>: string starting with apostrophe (<code>'</code>) . e.g.<code>'a</code></li>
<li><strong>Lists</strong>: <code>a list</code> where <code>a</code> is a type. e.g. <code>nat list</code></li>
<li><strong>Functions</strong>: <code>a -&gt; b</code> where <code>a</code> and <code>b</code> are types. e.g. <code>nat -&gt; nat</code></li>
<li><strong>Proposition Type</strong>: <code>prop</code></li>
</ul>
<p><a name="section3.1.2"></a></p>
<h4>Terms</h4>
<p>This data type category contains terms which give values to the different existing types.</p>
<ul>
<li>
<strong>Term Variables</strong>:
<ul>
<li>strings starting with lower-case letter, allowing <code>0-9</code> and <code>_</code>. e.g. <code>term_var_x</code></li>
</ul>
</li>
<li>
<strong>Function Application</strong>:
<ul>
<li>term applied to another term. e.g. <code>reverse xs</code>, where <code>reverse</code> is a term variable of type <code>nat list-&gt; nat list</code> and <code>xs</code> is a term variable of type <code>nat list</code>.</li>
</ul>
</li>
<li>
<strong>Boolean Terms</strong>:
<ul>
<li><code>true</code> and <code>false</code> of type <code>bool</code></li>
</ul>
</li>
<li>
<strong>Natural Numbers</strong>:
<ul>
<li><code>zero</code> and <code>suc n</code> where <code>n</code> is a term of type <code>nat</code>. e.g. <code>suc (suc zero)</code>.</li>
</ul>
</li>
<li>
<strong>Lists</strong>:
<ul>
<li><code>nil</code> or <code>[]</code> and <code>x :: xs</code> where <code>x</code> is a term of some type <code>a</code>, and <code>xs</code> is a list of the same type (<code>a list</code>).</li>
</ul>
</li>
</ul>
<p><a name="section3.1.3"></a></p>
<h4>Propositions</h4>
<p>This data type category contains propositions, which are the type for proofs and labelled by hypotheses. Propositions can contain terms in them, which is how terms are checked in the hierarchy.</p>
<ul>
<li><strong>Truth</strong> and <strong>Falsity</strong>: <code>Truth</code> and <code>Falsity</code> respectively</li>
<li>
<strong>Propositional Variables</strong>:
<ul>
<li>strings starting with upper-case letter, allowing <code>0-9</code> and <code>_</code>. e.g. <code>PROP_VAR_A</code>.</li>
</ul>
</li>
<li>
<strong>Conjunction</strong>:
<ul>
<li><code>A and B</code> where <code>A</code> and <code>B</code> are propositions.</li>
</ul>
</li>
<li>
<strong>Disjunction</strong>:
<ul>
<li><code>A or B</code> where <code>A</code> and <code>B</code> are propositions.</li>
</ul>
</li>
<li>
<strong>Implication</strong>:
<ul>
<li><code>A =&gt; B</code> where <code>A</code> and <code>B</code> are propositions.</li>
</ul>
</li>
<li>
<strong>Equality</strong>:
<ul>
<li><code>t_1 = t_2 : type</code> where <code>t_1</code> and <code>t_2</code> are terms and <code>type</code> is a type shared by both <code>t_1</code> and <code>t_2</code>. e.g. <code>suc n = suc n : nat</code>. </li>
</ul>
</li>
<li>
<strong>Universal and Existential Quantifiers</strong>:
<ul>
<li><code>forall x : type . A</code> where <code>x</code> is a term variable, <code>type</code> is a type, and <code>A</code> is a proposition. e.g. <code>forall n : nat . suc n = suc n : nat</code>. </li>
<li><code>exists x : type . A</code> where <code>x</code> is a term variable, <code>type</code> is a type, and <code>A</code> is a proposition. e.g. <code>exists x : bool . x = true : bool</code>.</li>
</ul>
</li>
</ul>
<p><a name="section3.1.4"></a></p>
<h4>Proofs</h4>
<p>The proof data type is made up of a set of rules that allow us to prove propositions. Proofs allow us to manipulate propositions, terms, and types in order to show a theorem holds. </p>
<ul>
<li><strong>Truth Introduction</strong>: <code>tt</code></li>
<li><strong>Falsity Elimination</strong>: <code>absurd [H]</code> where <code>[H]</code> is a hypothesis</li>
<li><strong>Conjunction Introduction</strong>: <code>(p , q)</code> where <code>p</code> and <code>q</code> are proofs.</li>
<li>
<p><strong>Conjunction Elimination</strong>: </p>
<pre><code>we know ([P] : P , [Q] : Q) because [P and Q] : P and Q . rest 
</code></pre>

<p>where <code>[P]</code> and <code>[Q]</code> are hypotheses of type <code>P</code> and <code>Q</code>, which are propositions, and <code>rest</code> is a proof where <code>[P]</code> and <code>[Q]</code> are in scope.</p>
</li>
<li>
<strong>Disjunction Introduction</strong>:
<ul>
<li><code>p on left</code> is a proof for <code>P or Q</code> where <code>p</code> is of type <code>P</code> and <code>Q</code> is any other proposition.</li>
<li><code>q on right</code> is a proof for <code>P or Q</code> where <code>q</code> is of type <code>Q</code> and <code>P</code> is any other proposition.</li>
</ul>
</li>
<li>
<p><strong>Disjunction Elimination</strong>:</p>
<pre><code>since [A or B] : A or B then either : 
case on left : [A] : A . p
case on right : [B] : B . q
</code></pre>

<p>where <code>[A or B]</code> is a hypothesis of type <code>A or B</code>, <code>[A]</code> is an hypothesis expected to be of type <code>A</code>, <code>[B]</code> is a hypothesis expected to be of type <code>B</code>, <code>p</code> is a proof where <code>[A]</code> is in scope, and <code>q</code> is a proof where <code>[B]</code> is in scope.</p>
</li>
<li>
<strong>Implication Introduction</strong>:
<ul>
<li><code>assume [A] : A . p</code> where <code>[A]</code> is a hypothesis of type <code>A</code>, <code>A</code> is a proposition, and <code>p</code> is a proof where <code>[A] : A</code> is in scope. </li>
</ul>
</li>
<li>
<p><strong>Implication Elimination</strong>:</p>
<pre><code>we know [B] : B because [A to B] : A =&gt; B with ([A]) . rest
</code></pre>

<p>where <code>[B]</code> is a new hypothesis of type <code>B</code>, <code>[A to B]</code> is an existing hypothesis of type <code>A =&gt; B</code>, <code>[A]</code> an existing hypothesis of type <code>A</code>, and <code>rest</code> a proof where the new hypothesis <code>[B]</code> is in scope.</p>
<p>Note that this rule is actually the combination of two rules, a hypothesis labelling clause (<code>we know [H] because p</code>), and a <code>with</code> clause (<code>[H] with (a,b,c)</code>). This will be mentioned in more detail in their own sections.</p>
</li>
<li>
<strong>Existential Introduction</strong>:
<ul>
<li><code>choose t . rest</code> where <code>t</code> is a term and <code>rest</code> is a proof where <code>t</code> is now in scope.</li>
</ul>
</li>
<li>
<p><strong>Existential Elimination</strong>:</p>
<pre><code>we know [new A] : A with x because [A] : exists x : type . A . rest
</code></pre>

<p>where <code>[new A]</code> is a new hypothesis where the existential surrounding <code>A</code> has been eliminated, <code>x</code> is term variable of type <code>type</code>, <code>[A]</code> is an old hypothesis of type <code>A</code>, <code>A</code> is a proposition, and <code>rest</code> is a proof where <code>[new A]</code> and <code>x</code> are in scope.</p>
</li>
<li>
<strong>Universal Introduction</strong>:
<ul>
<li><code>assume x : type . rest</code> where <code>x</code> is a term variable of type <code>type</code>, and <code>rest</code> is a proof where <code>x</code> is now in scope.</li>
</ul>
</li>
<li>
<p><strong>Universal Elimination</strong>:</p>
<pre><code>we know [y A] : A because [A] : forall x : type . A with (y) . rest
</code></pre>

<p>where <code>[y A]</code> is a hypothesis of type <code>A</code> where all instances of <code>x</code> have been replaced with term <code>y</code> in <code>A</code>, <code>[A]</code> a hypothesis, and <code>rest</code> is a proof where <code>[y A]</code> is in scope.</p>
<p>Note that this rule is actually the combination of two rules, a hypothesis labelling clause (<code>we know [H] because p</code>), and a <code>with</code> clause (<code>[H] with (a,b,c)</code>). This will be mentioned in more detail in their own sections.</p>
</li>
<li>
<p><strong>Induction on Natural Numbers</strong>:</p>
<pre><code>by induction on nat :
case zero : p
case (suc n) : [IH] : A . q
</code></pre>

<p>where in <code>case zero</code>, <code>p</code> is a proof of the proposition where the variable we are applying induction to is replaced with <code>zero</code>; and in <code>case (suc n)</code>, <code>suc n</code> is the <code>nat</code> replacing the variable in the inductive step, <code>[IH]</code> is the inductive hypothesis where the variable is replaced with <code>n</code>, and <code>q</code> is a proof where <code>n</code> and <code>[IH]</code> are in scope.</p>
</li>
<li>
<p><strong>Induction on Lists</strong>:</p>
<pre><code>by induction on list :
case [] : p
case (x :: xs) : [IH] : A . q
</code></pre>

<p>where in <code>case []</code>, <code>p</code> is a proof of the proposition where the variable we are applying induction to is replaced with <code>[]</code>; and in <code>case (x :: xs)</code>, <code>(x :: xs)</code> is the <code>list</code> replacing the variable in the inductive step, <code>[IH]</code> is the inductive hypothesis where the variable is replaced with <code>xs</code>, and <code>q</code> is a proof where <code>x</code>, <code>xs</code> and <code>[IH]</code> are in scope.</p>
</li>
<li>
<p><strong>Induction on Booleans</strong>:</p>
<pre><code>by induction on bool :
case true : p
case false : q
</code></pre>

<p>where <code>p</code> is a proof for the proposition with the inductive variable replaced with <code>true</code>, and <code>q</code> is a proof for the proposition with the inductive variable replced with <code>false</code>.</p>
</li>
<li>
<strong>Equality</strong>:
<ul>
<li><code>equality on ([H_1],[H_2],...,[H_n])</code> where <code>[H_1]</code> to <code>[H_n]</code> are the hypotheses used to prove equality of the desired terms, which would be stated by the proof's goal or statement.</li>
</ul>
</li>
<li>
<p><strong>Hypothesis Labelling Clause</strong>:</p>
<pre><code>we know [A] : A because p . rest
</code></pre>

<p>where <code>[A]</code> is a proof of type <code>A</code>, <code>p</code> is a proof for <code>A</code>, and <code>rest</code> is a proof where <code>[A]</code> is in scope. This is a form of hypothesis introduction, it labels a proven proposition with a hypothesis, and put's it in scope of the following proof.</p>
<p>Given this rule is useful to keep moving forward in a proof, and use proven propositions later in the same proof, it's commonly paired with almost every rule in the proof data type.</p>
<p>Note that you cannot give any proof after a <code>because</code> keyword. You can only give what is called a <code>simple proof</code>, <code>tt</code>, <code>(p , q)</code>, <code>p on left</code>, <code>q on right</code>, <code>equality on ([A],[B],[C])</code>, <code>by [H]</code>, <code>[H] with (a,[A])</code>, and <code>p therefore A</code>. i.e. no case elimination rules such as induction or disjunction elimination.</p>
</li>
<li>
<p><strong>With Clause</strong>:</p>
<pre><code>[H] with (a,b,c,[A],[B],C])
</code></pre>

<p>where <code>[H]</code> is a hypothesis labelling some proposition made of universal quantifiers or implications, and <code>a</code> to <code>c</code> are terms, while <code>[A]</code> to <code>[C]</code> are hypotheses.</p>
<p>The <code>with</code> clause is a form of elimination clause for universal quantifiers and implications. To eliminate a universal, provide a term that can replace the universal term variable. To eliminate an implication, provide a hypothesis which matches the proposition being eliminated.</p>
<p>Note that the elements we are providing for the elimination must be given inside a tuple, and in the correct order. i.e. When eliminating, you can only eliminate the outermost layer first. </p>
<p>For instance, to eliminate the following:</p>
<pre><code>[Some Hypothesis] : A =&gt; forall x : nat . C
</code></pre>

<p>We must first eliminate <code>A</code>, and then <code>x</code>.</p>
<p>Given: <code>[A] : A</code> and <code>y : nat</code>, we can do:</p>
<pre><code>[Some Hypothesis] with ([A],y)  
</code></pre>

</li>
<li>
<p><strong>Using Hypotheses</strong>:</p>
<ul>
<li>
<p><code>by [H]</code>where <code>[H]</code> is the hypothesis we want to use. Note that you must also include the <code>by</code> when combining this with a labelling clause. e.g.</p>
<pre><code>we know [A] : A because by [H] . p
</code></pre>

</li>
</ul>
</li>
<li>
<p><strong>Therefore Clause</strong>:</p>
<ul>
<li>
<p><code>p therefore A</code> where <code>p</code> is a proof of type <code>A</code>. This is mainly to label your proof with the proposition if it's confusing. </p>
<p>e.g. 
Given <code>[negation] : Falsity</code> we can do: <code>by [negation] therefore Falsity</code></p>
</li>
</ul>
</li>
</ul>
<p><a name="section3.1.5"></a></p>
<h4>Top-Level</h4>
<p>The top-level data type category contains the outermost hierarchical layer of the proof files. The first thing you write in a proof file is a top-level construct. In these, you can write proofs, propositions, and terms. A proof file can have multiple occurrences (or none) of these top-level constructs.</p>
<ul>
<li>
<p><strong>Signatures</strong>: </p>
<pre><code>Signatures:
    A : prop ;
    B : prop ;
    append : nat list -&gt; nat list -&gt; nat list ;
    rev    : nat list -&gt; nat list ;
</code></pre>

<p>where the word <code>Signatures:</code> is followed by a list of <code>variables</code> with corresponding <code>types</code>, each separated by a semi-colon (<code>;</code>). </p>
<p>Signatures are what contain the initial term and proposition variables to feed into the rest of the file's context. Every variable that appears in a <code>Signature</code> will be globally available (in scope) of every top-level construct underneath it. </p>
<p>This is because adding a variable into a <code>Signature</code> is the same as adding that variable into the context of the proof file at that point. Another way to think of <code>Signatures</code> is to think of them as appending to the <code>variables context</code> for the proof file at a given point.</p>
<p>The reason why I refer to context variables as <code>Signatures</code> is because variables with corresponding types are analogous to signatures in functional programs. This is why we can define a <code>function signature</code> such as <code>rev : nat list -&gt; nat list</code> and <code>append : nat list -&gt; nat list -&gt; nat list</code> in this section.  
</p>
</li>
<li>
<p><strong>Definitions</strong>:</p>
<pre><code>Definitions:
    [A to B] : A =&gt; B ;
    [not A]  : (A =&gt; Falsity) ;
    [DNE]    : ((A =&gt; Falsity) =&gt; Falsity) =&gt; A ;
    [append nil] : forall xs : nat list . append [] xs = xs : nat list ;
    [append xs]  : forall xs : nat list . 
                        forall x : nat . 
                            forall ys : nat list . 
                                append (x::xs) ys = 
                                    x :: append xs ys : nat list ;
    [rev nil] : rev [] = [] : nat list ;
    [rev xs]  : forall xs : nat list . 
                    forall x : nat . 
                        rev (x :: xs) = 
                                append (rev xs) (x :: []) : nat list ;
</code></pre>

<p>where the word <code>Definitions</code> is followed by a list of <code>hypotheses</code> with corresponding <code>proposition</code>, each separated by a semi-colon (<code>;</code>).</p>
<p><code>Definitions</code> are the <code>axioms</code> or <code>hypothesis context</code> of a proof file. It contains propositions that simply hold true, i.e. the <code>premises</code> of a <code>Theorem</code>. Note that you can define propositions that cannot be proven in this section, such as <code>double negation elimination</code>, which is necessary for classical logic.</p>
<p>All given <code>Definitions</code> will be fed into the rest of the file's <code>hypothesis context</code>, and thus be globally available (in scope) of any top-level construct underneath it.</p>
<p><code>Definitions</code> get their name from the analogy to <code>program definitions</code> in functional programs. For instance, in <code>Haskell</code>, after writing a <code>function signature</code>, we provide a <code>function definition</code> that states what the program of the function is, i.e. what the function does.</p>
</li>
<li>
<p><strong>Theorems</strong>:</p>
<pre><code>Theorem [P to Z]:
    Statement: P =&gt; Z
    Proof:
        assume [P] : P .
        we know [Q] : Q because [P to Q] with ([P]) .
        we know [Z] : Z because [Q to Z] with ([Q]) .
        by [Z]
    QED.
</code></pre>

<p>where the word <code>Theorem</code> is followed by a hypothesis to call the theorem - in this case <code>[P to Z]</code>. The keyword <code>Statement</code> is followed by the proposition that we are trying to prove in this theorem labelled <code>[P to Z]</code>, which is <code>P =&gt; Z</code>. The keyword <code>Proof</code> is followed by the proof for the <code>Statement</code> of this <code>Theorem</code>.</p>
<p><code>Theorems</code> are like <code>Definitions</code> in the sense that they add <code>hypotheses</code> into the <code>hypothesis context</code> of a proof file. Every proven <code>Theorem</code> will be available globablly (in scope) to any top-level constructs underneath it.</p>
<p><code>Theorems</code> allow us to to prove propositions. This is where the <code>Proof Checker</code> does it's main job, which is to validate the correctness of a given proof. <code>propositions</code>, <code>terms</code> and <code>types</code> will also be checked for well-formedness when fed into the file as a <code>Signature</code> or <code>Definition</code>, but proofs can only be checked within a <code>Theorem</code>.</p>
<p>All Theorem proofs must end with the keyword <code>QED.</code>.
<a name="section3.2"></a></p>
</li>
</ul>
<h3>Organisation of Proof Files</h3>
<p>Under the hood, a proof file contains two data-structures which the proof checker has to keep track of:</p>
<ul>
<li>
<strong>Variable context</strong>:
<ul>
<li>This is the set where all <code>term</code> and <code>proposition</code> variables are held. This is a set of pairs <code>variable , type</code>, so the checker can tell what type any given variable has.</li>
</ul>
</li>
<li>
<strong>Hypothesis context</strong>:
<ul>
<li>This is the set where all <code>hypotheses</code> are held. This is a set of pairs <code>hypothesis , proposition</code>, so the checker can tell what proposition any given hypothesis is labelling.</li>
</ul>
</li>
</ul>
<p>The <code>top-level</code> constructs simply feed into either of these contexts if they pass their corresponding check:</p>
<ul>
<li>
<p><strong>Signatures</strong>: </p>
<ul>
<li>
<p>These add to the variable context only if the <code>type</code> is well-formed. For instance:</p>
<pre><code>Signatures:
    A   : prop ;
    rev : nat list -&gt; nat list ;
</code></pre>

<p>will only add <code>A</code> and <code>rev</code> into the variable context if <code>prop</code> and <code>nat list -&gt; nat list</code> are well-formed <code>types</code>. </p>
</li>
</ul>
</li>
<li>
<p><strong>Definitions</strong>: </p>
<ul>
<li>
<p>These add to the hypothesis context only if the <code>proposition</code> is well-formed. For instance:</p>
<pre><code>Definitions:
    [A to B] : A =&gt; B ;
    [not A]  : (A =&gt; Falsity) ;
    [plus 1] : forall n : nat . suc n
</code></pre>

<p>will only add <code>[A to B]</code>, <code>[not A]</code> and <code>[plus 1]</code> into the hypothesis context if <code>A =&gt; B</code>, <code>(A =&gt; Falsity)</code>, and <code>forall n : nat . suc n</code> are respectively well-formed <code>propositions</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Theorems</strong>: </p>
<ul>
<li>
<p>These add to the hypothesis context the <code>Theorem</code> label, and it's corresponding <code>Statement</code> only if the <code>Statement</code> is a well-formed proposition and the proof provided under <code>Proof</code> is valid. For instance:</p>
<pre><code>Theorem [not (P and not P)]:
    Statement: (P and (P =&gt; Falsity)) =&gt; Falsity
    Proof:
        assume [P and not P] : P and (P =&gt; Falsity) .
        we know [P] : P , [not P] : P =&gt; Falsity 
            because [P and not P] .
        we know [negation] : Falsity 
            because [not P] with ([P]) .
        by [negation]
    QED.
</code></pre>

<p>will only be added to the hypothesis context if the <code>Statement</code>, <code>(P and (P =&gt; Falsity)) =&gt; Falsity</code> is valid and the <code>Proof</code> is indeed a proof for <code>(P and (P =&gt; Falsity)) =&gt; Falsity</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Comments</strong>: comments are in <code>ML</code> style. Everything between <code>(*</code> and <code>*)</code> is a comment.</p>
</li>
</ul>
<p><a name="section4"></a></p>
<h2>Examples</h2>
<p>These are shortened proofs. For complete proofs and more sample proofs, <a href="file:///D:/extra/sample_proofs">extra/sample_proofs</a>.</p>
<p><a name="section4.1"></a></p>
<h3>Law of Excluded Middle</h3>
<pre><code>Signatures:
    P : prop ;

Definitions:
    [DNE] : ((P =&gt; Falsity) =&gt; Falsity) =&gt; P ;
    [not P] : ((P or (P =&gt; Falsity)) =&gt; Falsity) =&gt; (P =&gt; Falsity) ;
    [not not P] : ((P or (P =&gt; Falsity)) =&gt; Falsity) 
                    =&gt; ((P =&gt; Falsity) =&gt; Falsity) ;

Theorem [not not (P or not P)]:
    Statement: ((P or (P =&gt; Falsity)) =&gt; Falsity ) =&gt; Falsity
    Proof:
        assume [not (P or not P)] : (P or (P =&gt; Falsity)) =&gt; Falsity .
        we know [not P] : P =&gt; Falsity 
            because [not P] with ([not (P or not P)]) .
        we know [not not P] : (P =&gt; Falsity) =&gt; Falsity 
            because [not not P] with ([not (P or not P)]) .
        we know [P] : P because [DNE] with ([not not P]) .
        we know [negation] : Falsity because [not P] with ([P]) .
        by [negation]
    QED.

Theorem [excluded middle]:
    Statement: P or (P =&gt; Falsity)
    Proof:
        we get [New DNE] :
            (((P or (P =&gt; Falsity)) =&gt; Falsity) =&gt; Falsity) 
                =&gt; (P or (P =&gt; Falsity))
        instantiating [DNE] with (P is (P or (P =&gt; Falsity))) .
        [New DNE] with ([not not (P or not P)])
    QED.
</code></pre>

<p>Note that many aspects of the proof are stylistic. For instance, to make it clearer, the proof for <code>[not not (P or not P)]</code> ends with <code>by [negation]</code>. This could be compacted since the last step is redundant. e.g.</p>
<pre><code>    we know [negation] : Falsity because [not P] with ([P]) .
    by [negation]
</code></pre>

<p>becomes</p>
<pre><code>    [not P] with ([P])
</code></pre>

<p>However, this is not as clear as stating <code>by [negation]</code>. Another example of this can be seen with <code>[New DNE] with ([not not (P or not P)])</code>. Here, no final <code>by</code> step is used. If we wanted to make it clearer, we could annotate it with a <code>therefore</code> clause.</p>
<pre><code>    [New DNE] with ([not not (P or not P)])
</code></pre>

<p>becomes</p>
<pre><code>    [New DNE] with ([not not (P or not P)]) therefore  P or (P =&gt; Falsity)
</code></pre>

<p>Additionally, <code>hypotheses</code> generally have an optional annotation. In <code>we know</code> and <code>we get</code> clauses, this annotation is compulsory. In others, it might not be. For instance:</p>
<pre><code>    by [negation]
</code></pre>

<p>becomes</p>
<pre><code>    by [negation] : Falsity
</code></pre>

<p>with the optional annotation.</p>
<p><a name="section4.2"></a></p>
<h3>Involution of Reversing a List</h3>
<pre><code>Signatures:
    append : nat list -&gt; nat list -&gt; nat list ;
    rev    : nat list -&gt; nat list ;

Definitions:
    [append nil] : forall xs : nat list . append [] xs = xs : nat list ;
    [append xs]  : forall xs : nat list . 
                    forall x : nat . 
                        forall ys : nat list . 
                            append (x::xs) ys = x :: append xs ys : nat list ;
    [rev nil]    : rev [] = [] : nat list ;
    [rev xs]     : forall xs : nat list . 
                    forall x : nat . 
                        rev (x :: xs) = append (rev xs) (x :: []) : nat list ;
    [rev lemma]  : forall xs : nat list . 
                    forall x : nat . 
                        rev (append xs (x::[])) = x :: (rev xs) : nat list ;

Theorem [involution of rev] :
    Statement: forall xs : nat list . rev (rev xs) = xs : nat list
    Proof:
        by induction on list :

        case [] :
            equality on ([rev nil])

        case (hd :: tl) : [inductive hypothesis] .
            we know [step 1] : rev (hd :: tl) = 
                                append (rev tl) (hd::[]) : nat list 
            because [rev xs] with (tl,hd).

            we know [step 2] : rev (append (rev tl) (hd::[])) = 
                                hd :: (rev (rev tl)) : nat list 
            because [rev lemma] with (rev tl,hd) .

            equality on ([step 1], [step 2], [inductive hypothesis])
    QED.
</code></pre>

<p>Like the previous example, here we too have optional annotations. the inductive hypothesis, <code>[inductive hypothesis]</code> doesn't need a proposition annotation. It is just there to make things clearer. </p>
<p>Note that even though it's redundant, if you do decide to give it an annotation, it must match against the expected proposition. If it doesn't, then the proof will fail on the incorrect annotation and give you the corresponding error message.</p>



<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
</body></html>