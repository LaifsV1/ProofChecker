Signatures:
    append : nat list -> nat list -> nat list ; 
    rev    : nat list -> nat list ;

Definitions: 
    [append nil] : forall xs : nat list . append [] xs = xs : nat list ;
    [append ys]  : forall xs : nat list . forall ys : nat list . forall y : nat . append (y::ys) xs = y :: append ys xs : nat list ;
    [rev nil]    : rev [] = [] : nat list ;
    [rev xs]     : forall x : nat . forall xs : nat list . rev (x :: xs) = append (rev xs) (x :: []) : nat list ;
    [rev lemma]  : forall x : nat . forall xs : nat list . rev (append xs (x::[])) = x :: (rev xs) : nat list ;

Theorem [involution rev] : 
    Statement: forall xs : nat list . rev (rev xs) = xs : nat list
    Proof:
	
        by induction on list :
        
        case [] : 
		
            by equality on ([rev nil])
            
        case (hd :: tl) : [inductive hypothesis] : rev (rev tl) = tl : nat list .
            
            we know [step 1] : (rev (hd::tl) = append (rev tl) (hd::[]) : nat list) 
                because [rev xs] with (hd,tl) .
            we know [step 2] : (rev (append (rev tl) (hd::[])) = hd :: (rev (rev tl)) : nat list) 
                because [rev lemma] with (hd,rev tl) .
            by equality on ([step 1], [step 2], [inductive hypothesis])
			
    QED.