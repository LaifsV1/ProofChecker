
** Conflict (shift/reduce) in state 366.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

WeKnow_PROOF HVAR COLON prop Because_PROOF proof DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 366, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

WeKnow_PROOF HVAR COLON prop Because_PROOF proof DOT proof 
                                                     proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 366, looking ahead at DOT, reducing production
** proof -> WeKnow_PROOF HVAR COLON prop Because_PROOF proof DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
WeKnow_PROOF HVAR COLON prop Because_PROOF proof DOT proof . 

** Conflict (shift/reduce) in state 363.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Right_PROOF proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 363, looking ahead at DOT, reducing production
** proof -> Right_PROOF proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Right_PROOF proof . 

** In state 363, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Right_PROOF proof 
            proof . DOT h_var Because_PROOF h_var DOT proof 

** Conflict (shift/reduce) in state 358.
** Tokens involved: DOT COMMA CLOSE_PAREN
** The following explanations concentrate on token DOT.
** This state is reached from proof_toplevel after reading:

OPEN_PAREN proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 358, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

OPEN_PAREN proof COMMA proof CLOSE_PAREN 
           proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 358, looking ahead at DOT, reducing production
** spf_errors -> OPEN_PAREN proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
simple_proof // lookahead token is inherited
spf_errors // lookahead token is inherited
OPEN_PAREN proof . 

** Conflict (shift/reduce) in state 357.
** Token involved: CLOSE_PAREN
** This state is reached from proof_toplevel after reading:

OPEN_PAREN HVAR COLON prop 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
(?)

** In state 357, looking ahead at CLOSE_PAREN, reducing production
** h_var -> HVAR COLON prop 
** is permitted because of the following sub-derivation:

OPEN_PAREN proof CLOSE_PAREN // lookahead token appears
           simple_proof // lookahead token is inherited
           spf_errors // lookahead token is inherited
           h_var // lookahead token is inherited
           HVAR COLON prop . 

** In state 357, looking ahead at CLOSE_PAREN, shifting is permitted
** because of the following sub-derivation:

h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
OPEN_PAREN HVAR COLON prop . CLOSE_PAREN 

** Conflict (shift/reduce) in state 354.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Match_PROOF h_var With_PROOF h_var DOT proof PIPE h_var DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 354, looking ahead at DOT, reducing production
** proof -> Match_PROOF h_var With_PROOF h_var DOT proof PIPE h_var DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Match_PROOF h_var With_PROOF h_var DOT proof PIPE h_var DOT proof . 

** In state 354, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Match_PROOF h_var With_PROOF h_var DOT proof PIPE h_var DOT proof 
                                                            proof . DOT h_var Because_PROOF h_var DOT proof 

** Conflict (shift/reduce) in state 347.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Match_PROOF h_var With_PROOF PIPE h_var DOT proof PIPE h_var DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 347, looking ahead at DOT, reducing production
** proof -> Match_PROOF h_var With_PROOF PIPE h_var DOT proof PIPE h_var DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Match_PROOF h_var With_PROOF PIPE h_var DOT proof PIPE h_var DOT proof . 

** In state 347, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Match_PROOF h_var With_PROOF PIPE h_var DOT proof PIPE h_var DOT proof 
                                                                 proof . DOT h_var Because_PROOF h_var DOT proof 

** Conflict (shift/reduce) in state 342.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Let_PROOF h_pair Eq_OP h_var In_PROOF proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 342, looking ahead at DOT, reducing production
** proof -> Let_PROOF h_pair Eq_OP h_var In_PROOF proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Let_PROOF h_pair Eq_OP h_var In_PROOF proof . 

** In state 342, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Let_PROOF h_pair Eq_OP h_var In_PROOF proof 
                                      proof . DOT h_var Because_PROOF h_var DOT proof 

** Conflict (shift/reduce) in state 334.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Let_PROOF h_var Eq_OP h_var With_PROOF term In_PROOF proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 334, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Let_PROOF h_var Eq_OP h_var With_PROOF term In_PROOF proof 
                                                     proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 334, looking ahead at DOT, reducing production
** proof -> Let_PROOF h_var Eq_OP h_var With_PROOF term In_PROOF proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Let_PROOF h_var Eq_OP h_var With_PROOF term In_PROOF proof . 

** Conflict (shift/reduce) in state 315.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Let_PROOF VAR COMMA h_var Eq_OP h_var In_PROOF proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 315, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Let_PROOF VAR COMMA h_var Eq_OP h_var In_PROOF proof 
                                               proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 315, looking ahead at DOT, reducing production
** proof -> Let_PROOF VAR COMMA h_var Eq_OP h_var In_PROOF proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Let_PROOF VAR COMMA h_var Eq_OP h_var In_PROOF proof . 

** Conflict (shift/reduce) in state 314.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Left_PROOF proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 314, looking ahead at DOT, reducing production
** proof -> Left_PROOF proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Left_PROOF proof . 

** In state 314, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Left_PROOF proof 
           proof . DOT h_var Because_PROOF h_var DOT proof 

** Conflict (shift/reduce) in state 313.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Choose_PROOF term DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 313, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Choose_PROOF term DOT proof 
                      proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 313, looking ahead at DOT, reducing production
** proof -> Choose_PROOF term DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Choose_PROOF term DOT proof . 

** Conflict (shift/reduce) in state 304.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

By_PROOF Induction_PROOF Bool_TYPE COLON Case_PROOF True_TERM COLON proof Case_PROOF False_TERM COLON proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 304, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

By_PROOF Induction_PROOF Bool_TYPE COLON Case_PROOF True_TERM COLON proof Case_PROOF False_TERM COLON proof 
                                                                                                      proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 304, looking ahead at DOT, reducing production
** proof -> By_PROOF Induction_PROOF Bool_TYPE COLON Case_PROOF True_TERM COLON proof Case_PROOF False_TERM COLON proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
By_PROOF Induction_PROOF Bool_TYPE COLON Case_PROOF True_TERM COLON proof Case_PROOF False_TERM COLON proof . 

** Conflict (shift/reduce) in state 293.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

By_PROOF Induction_PROOF List_TYPE_OP COLON Case_PROOF Nil_TERM COLON proof Case_PROOF OPEN_PAREN VAR Cons_TERM_OP VAR CLOSE_PAREN COLON h_var DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 293, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

By_PROOF Induction_PROOF List_TYPE_OP COLON Case_PROOF Nil_TERM COLON proof Case_PROOF OPEN_PAREN VAR Cons_TERM_OP VAR CLOSE_PAREN COLON h_var DOT proof 
                                                                                                                                                   proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 293, looking ahead at DOT, reducing production
** proof -> By_PROOF Induction_PROOF List_TYPE_OP COLON Case_PROOF Nil_TERM COLON proof Case_PROOF OPEN_PAREN VAR Cons_TERM_OP VAR CLOSE_PAREN COLON h_var DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
By_PROOF Induction_PROOF List_TYPE_OP COLON Case_PROOF Nil_TERM COLON proof Case_PROOF OPEN_PAREN VAR Cons_TERM_OP VAR CLOSE_PAREN COLON h_var DOT proof . 

** Conflict (shift/reduce) in state 276.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

By_PROOF Induction_PROOF Nat_TYPE COLON Case_PROOF Zero_TERM COLON proof Case_PROOF OPEN_PAREN Suc_TERM_OP VAR CLOSE_PAREN COLON h_var DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 276, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

By_PROOF Induction_PROOF Nat_TYPE COLON Case_PROOF Zero_TERM COLON proof Case_PROOF OPEN_PAREN Suc_TERM_OP VAR CLOSE_PAREN COLON h_var DOT proof 
                                                                                                                                           proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 276, looking ahead at DOT, reducing production
** proof -> By_PROOF Induction_PROOF Nat_TYPE COLON Case_PROOF Zero_TERM COLON proof Case_PROOF OPEN_PAREN Suc_TERM_OP VAR CLOSE_PAREN COLON h_var DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
By_PROOF Induction_PROOF Nat_TYPE COLON Case_PROOF Zero_TERM COLON proof Case_PROOF OPEN_PAREN Suc_TERM_OP VAR CLOSE_PAREN COLON h_var DOT proof . 

** Conflict (shift/reduce) in state 268.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

By_PROOF Induction_PROOF Nat_TYPE COLON Case_PROOF Zero_TERM COLON proof Case_PROOF Suc_TERM_OP VAR COLON h_var DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 268, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

By_PROOF Induction_PROOF Nat_TYPE COLON Case_PROOF Zero_TERM COLON proof Case_PROOF Suc_TERM_OP VAR COLON h_var DOT proof 
                                                                                                                    proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 268, looking ahead at DOT, reducing production
** proof -> By_PROOF Induction_PROOF Nat_TYPE COLON Case_PROOF Zero_TERM COLON proof Case_PROOF Suc_TERM_OP VAR COLON h_var DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
By_PROOF Induction_PROOF Nat_TYPE COLON Case_PROOF Zero_TERM COLON proof Case_PROOF Suc_TERM_OP VAR COLON h_var DOT proof . 

** Conflict (shift/reduce) in state 260.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Assume_PROOF h_var DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 260, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Assume_PROOF h_var DOT proof 
                       proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 260, looking ahead at DOT, reducing production
** proof -> Assume_PROOF h_var DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Assume_PROOF h_var DOT proof . 

** Conflict (shift/reduce) in state 239.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

proof DOT h_var Because_PROOF h_var DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 239, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof 
                                        proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 239, looking ahead at DOT, reducing production
** proof -> proof DOT h_var Because_PROOF h_var DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
proof DOT h_var Because_PROOF h_var DOT proof . 

** Conflict (shift/reduce) in state 231.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Assume_PROOF VAR COLON complex_type DOT proof 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 231, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

Assume_PROOF VAR COLON complex_type DOT proof 
                                        proof . DOT h_var Because_PROOF h_var DOT proof 

** In state 231, looking ahead at DOT, reducing production
** proof -> Assume_PROOF VAR COLON complex_type DOT proof 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
Assume_PROOF VAR COLON complex_type DOT proof . 

** Conflict (reduce/reduce) in state 209.
** Token involved: DOT
** This state is reached from proof_toplevel after reading:

Choose_PROOF error 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
(?)

** In state 209, looking ahead at DOT, reducing production
** proof_errors -> Choose_PROOF error 
** is permitted because of the following sub-derivation:

proof DOT h_var Because_PROOF h_var DOT proof // lookahead token appears
proof_errors // lookahead token is inherited
Choose_PROOF error . 

** In state 209, looking ahead at DOT, reducing production
** term_errors -> error 
** is permitted because of the following sub-derivation:

Choose_PROOF term DOT proof // lookahead token appears
             term_errors // lookahead token is inherited
             error . 

** Conflict (shift/reduce) in state 204.
** Tokens involved: Or_PROP_OP Implies_PROP_OP CLOSE_PAREN And_PROP_OP
** The following explanations concentrate on token Or_PROP_OP.
** This state is reached from proof_toplevel after reading:

HVAR COLON OPEN_PAREN prop 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           (?)

** In state 204, looking ahead at Or_PROP_OP, shifting is permitted
** because of the following sub-derivation:

simple_prop 
OPEN_PAREN prop CLOSE_PAREN 
           prop . Or_PROP_OP prop 

** In state 204, looking ahead at Or_PROP_OP, reducing production
** prop_errors -> OPEN_PAREN prop 
** is permitted because of the following sub-derivation:

prop Or_PROP_OP prop // lookahead token appears
prop_errors // lookahead token is inherited
OPEN_PAREN prop . 

** Conflict (shift/reduce) in state 200.
** Token involved: CLOSE_PAREN
** This state is reached from proof_toplevel after reading:

HVAR COLON OPEN_PAREN term Eq_OP term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           (?)

** In state 200, looking ahead at CLOSE_PAREN, shifting is permitted
** because of the following sub-derivation:

OPEN_PAREN term Eq_OP term . CLOSE_PAREN COLON complex_type 

** In state 200, looking ahead at CLOSE_PAREN, reducing production
** prop_errors -> term Eq_OP term 
** is permitted because of the following sub-derivation:

simple_prop 
OPEN_PAREN prop CLOSE_PAREN // lookahead token appears
           prop_errors // lookahead token is inherited
           term Eq_OP term . 

** Conflict (shift/reduce) in state 198.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM Eq_OP Cons_TERM_OP CLOSE_PAREN
** The following explanations concentrate on token Zero_TERM.
** This state is reached from proof_toplevel after reading:

HVAR COLON OPEN_PAREN term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           (?)

** In state 198, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

OPEN_PAREN term Eq_OP term CLOSE_PAREN COLON complex_type 
           term simple_term 
                . Zero_TERM 

** In state 198, looking ahead at Zero_TERM, reducing production
** term_errors -> OPEN_PAREN term 
** is permitted because of the following sub-derivation:

term Eq_OP term COLON complex_type 
term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term_errors // lookahead token is inherited
OPEN_PAREN term . 

** Conflict (shift/reduce) in state 196.
** Tokens involved: Or_PROP_OP Implies_PROP_OP And_PROP_OP
** The following explanations concentrate on token Or_PROP_OP.
** This state is reached from proof_toplevel after reading:

HVAR COLON Forall_PROP VAR COLON complex_type DOT prop 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           (?)

** In state 196, looking ahead at Or_PROP_OP, shifting is permitted
** because of the following sub-derivation:

Forall_PROP VAR COLON complex_type DOT prop 
                                       prop . Or_PROP_OP prop 

** In state 196, looking ahead at Or_PROP_OP, reducing production
** prop -> Forall_PROP VAR COLON complex_type DOT prop 
** is permitted because of the following sub-derivation:

prop Or_PROP_OP prop // lookahead token appears
Forall_PROP VAR COLON complex_type DOT prop . 

** Conflict (shift/reduce) in state 194.
** Token involved: error
** This state is reached from proof_toplevel after reading:

HVAR COLON prop Implies_PROP_OP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
(?)

** In state 194, looking ahead at error, reducing production
** prop_errors -> prop Implies_PROP_OP 
** is permitted because of the following sub-derivation:

spf_errors 
h_var error // lookahead token appears
HVAR COLON prop // lookahead token is inherited
           prop_errors // lookahead token is inherited
           prop Implies_PROP_OP . 

** In state 194, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           prop Implies_PROP_OP prop 
                                prop_errors 
                                . error 

** Conflict (shift/reduce) in state 192.
** Token involved: error
** This state is reached from proof_toplevel after reading:

HVAR COLON prop And_PROP_OP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
(?)

** In state 192, looking ahead at error, reducing production
** prop_errors -> prop And_PROP_OP 
** is permitted because of the following sub-derivation:

spf_errors 
h_var error // lookahead token appears
HVAR COLON prop // lookahead token is inherited
           prop_errors // lookahead token is inherited
           prop And_PROP_OP . 

** In state 192, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           prop And_PROP_OP prop 
                            prop_errors 
                            . error 

** Conflict (shift/reduce) in state 190.
** Token involved: error
** This state is reached from proof_toplevel after reading:

HVAR COLON prop Or_PROP_OP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
(?)

** In state 190, looking ahead at error, reducing production
** prop_errors -> prop Or_PROP_OP 
** is permitted because of the following sub-derivation:

spf_errors 
h_var error // lookahead token appears
HVAR COLON prop // lookahead token is inherited
           prop_errors // lookahead token is inherited
           prop Or_PROP_OP . 

** In state 190, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           prop Or_PROP_OP prop 
                           prop_errors 
                           . error 

** Conflict (shift/reduce) in state 189.
** Tokens involved: Or_PROP_OP Implies_PROP_OP And_PROP_OP
** The following explanations concentrate on token Or_PROP_OP.
** This state is reached from proof_toplevel after reading:

HVAR COLON Exists_PROP VAR COLON complex_type DOT prop 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           (?)

** In state 189, looking ahead at Or_PROP_OP, shifting is permitted
** because of the following sub-derivation:

Exists_PROP VAR COLON complex_type DOT prop 
                                       prop . Or_PROP_OP prop 

** In state 189, looking ahead at Or_PROP_OP, reducing production
** prop -> Exists_PROP VAR COLON complex_type DOT prop 
** is permitted because of the following sub-derivation:

prop Or_PROP_OP prop // lookahead token appears
Exists_PROP VAR COLON complex_type DOT prop . 

** Conflict (shift/reduce) in state 184.
** Tokens involved: List_TYPE_OP CLOSE_PAREN Arrow_TYPE_OP
** The following explanations concentrate on token List_TYPE_OP.
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP term COLON OPEN_PAREN complex_type 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                                 (?)

** In state 184, looking ahead at List_TYPE_OP, shifting is permitted
** because of the following sub-derivation:

simple_type 
OPEN_PAREN complex_type CLOSE_PAREN 
           complex_type . List_TYPE_OP 

** In state 184, looking ahead at List_TYPE_OP, reducing production
** type_errors -> OPEN_PAREN complex_type 
** is permitted because of the following sub-derivation:

complex_type List_TYPE_OP // lookahead token appears
type_errors // lookahead token is inherited
OPEN_PAREN complex_type . 

** Conflict (shift/reduce) in state 183.
** Token involved: List_TYPE_OP
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP term COLON complex_type Arrow_TYPE_OP complex_type 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                                 (?)

** In state 183, looking ahead at List_TYPE_OP, reducing production
** complex_type -> complex_type Arrow_TYPE_OP complex_type 
** is permitted because of the following sub-derivation:

complex_type List_TYPE_OP // lookahead token appears
complex_type Arrow_TYPE_OP complex_type . 

** In state 183, looking ahead at List_TYPE_OP, shifting is permitted
** because of the following sub-derivation:

complex_type Arrow_TYPE_OP complex_type 
                           complex_type . List_TYPE_OP 

** Conflict (shift/reduce) in state 182.
** Tokens involved: error List_TYPE_OP
** The following explanations concentrate on token error.
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP term COLON complex_type Arrow_TYPE_OP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
(?)

** In state 182, looking ahead at error, reducing production
** type_errors -> complex_type Arrow_TYPE_OP 
** is permitted because of the following sub-derivation:

spf_errors 
h_var error // lookahead token appears
HVAR COLON prop // lookahead token is inherited
           term Eq_OP term COLON complex_type // lookahead token is inherited
                                 type_errors // lookahead token is inherited
                                 complex_type Arrow_TYPE_OP . 

** In state 182, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                                 complex_type Arrow_TYPE_OP complex_type 
                                                            type_errors 
                                                            . error 

** Conflict (shift/reduce) in state 180.
** Token involved: List_TYPE_OP
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP term COLON Arrow_TYPE_OP complex_type 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                                 (?)

** In state 180, looking ahead at List_TYPE_OP, shifting is permitted
** because of the following sub-derivation:

type_errors 
Arrow_TYPE_OP complex_type 
              complex_type . List_TYPE_OP 

** In state 180, looking ahead at List_TYPE_OP, reducing production
** type_errors -> Arrow_TYPE_OP complex_type 
** is permitted because of the following sub-derivation:

complex_type List_TYPE_OP // lookahead token appears
type_errors // lookahead token is inherited
Arrow_TYPE_OP complex_type . 

** Conflict (shift/reduce) in state 165.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM Cons_TERM_OP
** The following explanations concentrate on token Zero_TERM.
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP Suc_TERM_OP term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                      (?)

** In state 165, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

Suc_TERM_OP term 
            term simple_term 
                 . Zero_TERM 

** In state 165, looking ahead at Zero_TERM, reducing production
** term -> Suc_TERM_OP term 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
Suc_TERM_OP term . 

** Conflict (shift/reduce) in state 164.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM Cons_TERM_OP CLOSE_PAREN
** The following explanations concentrate on token Zero_TERM.
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP OPEN_PAREN term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                      (?)

** In state 164, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

simple_term 
OPEN_PAREN term CLOSE_PAREN 
           term simple_term 
                . Zero_TERM 

** In state 164, looking ahead at Zero_TERM, reducing production
** term_errors -> OPEN_PAREN term 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term_errors // lookahead token is inherited
OPEN_PAREN term . 

** Conflict (shift/reduce) in state 161.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM
** The following explanations concentrate on token Zero_TERM.
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP term Cons_TERM_OP term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                      (?)

** In state 161, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

term Cons_TERM_OP term 
                  term simple_term 
                       . Zero_TERM 

** In state 161, looking ahead at Zero_TERM, reducing production
** term -> term Cons_TERM_OP term 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term Cons_TERM_OP term . 

** Conflict (shift/reduce) in state 160.
** Tokens involved: error Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM
** The following explanations concentrate on token error.
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP term Cons_TERM_OP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
(?)

** In state 160, looking ahead at error, reducing production
** term_errors -> term Cons_TERM_OP 
** is permitted because of the following sub-derivation:

spf_errors 
h_var error // lookahead token appears
HVAR COLON prop // lookahead token is inherited
           prop_errors // lookahead token is inherited
           term Eq_OP term // lookahead token is inherited
                      term_errors // lookahead token is inherited
                      term Cons_TERM_OP . 

** In state 160, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                      term Cons_TERM_OP term 
                                        term_errors 
                                        . error 

** Conflict (shift/reduce) in state 156.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM
** The following explanations concentrate on token Zero_TERM.
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP Cons_TERM_OP term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                      (?)

** In state 156, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

term_errors 
Cons_TERM_OP term 
             term simple_term 
                  . Zero_TERM 

** In state 156, looking ahead at Zero_TERM, reducing production
** term_errors -> Cons_TERM_OP term 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term_errors // lookahead token is inherited
Cons_TERM_OP term . 

** Conflict (shift/reduce) in state 150.
** Tokens involved: error Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM Cons_TERM_OP
** The following explanations concentrate on token error.
** This state is reached from proof_toplevel after reading:

HVAR COLON term Eq_OP Suc_TERM_OP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
(?)

** In state 150, looking ahead at error, reducing production
** term_errors -> Suc_TERM_OP 
** is permitted because of the following sub-derivation:

spf_errors 
h_var error // lookahead token appears
HVAR COLON prop // lookahead token is inherited
           prop_errors // lookahead token is inherited
           term Eq_OP term // lookahead token is inherited
                      term_errors // lookahead token is inherited
                      Suc_TERM_OP . 

** In state 150, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           term Eq_OP term COLON complex_type 
                      Suc_TERM_OP term 
                                  term_errors 
                                  . error 

** Conflict (reduce/reduce) in state 127.
** Tokens involved: Eq_OP CLOSE_PAREN
** The following explanations concentrate on token CLOSE_PAREN.
** This state is reached from proof_toplevel after reading:

HVAR COLON OPEN_PAREN error 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

proof_toplevel 
proof EOF 
simple_proof 
h_var With_PROOF OPEN_PAREN spine CLOSE_PAREN 
HVAR COLON prop 
           (?)

** In state 127, looking ahead at CLOSE_PAREN, reducing production
** prop_errors -> error 
** is permitted because of the following sub-derivation:

simple_prop 
OPEN_PAREN prop CLOSE_PAREN // lookahead token appears
           prop_errors // lookahead token is inherited
           error . 

** In state 127, looking ahead at CLOSE_PAREN, reducing production
** term_errors -> error 
** is permitted because of the following sub-derivation:

term Eq_OP term COLON complex_type 
simple_term 
OPEN_PAREN term CLOSE_PAREN // lookahead token appears
           term_errors // lookahead token is inherited
           error . 

** Conflict (shift/reduce) in state 84.
** Tokens involved: Or_PROP_OP Implies_PROP_OP CLOSE_PAREN And_PROP_OP
** The following explanations concentrate on token Or_PROP_OP.
** This state is reached from prop_toplevel after reading:

OPEN_PAREN prop 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
(?)

** In state 84, looking ahead at Or_PROP_OP, shifting is permitted
** because of the following sub-derivation:

simple_prop 
OPEN_PAREN prop CLOSE_PAREN 
           prop . Or_PROP_OP prop 

** In state 84, looking ahead at Or_PROP_OP, reducing production
** prop_errors -> OPEN_PAREN prop 
** is permitted because of the following sub-derivation:

prop Or_PROP_OP prop // lookahead token appears
prop_errors // lookahead token is inherited
OPEN_PAREN prop . 

** Conflict (shift/reduce) in state 80.
** Token involved: CLOSE_PAREN
** This state is reached from prop_toplevel after reading:

OPEN_PAREN term Eq_OP term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
(?)

** In state 80, looking ahead at CLOSE_PAREN, shifting is permitted
** because of the following sub-derivation:

OPEN_PAREN term Eq_OP term . CLOSE_PAREN COLON complex_type 

** In state 80, looking ahead at CLOSE_PAREN, reducing production
** prop_errors -> term Eq_OP term 
** is permitted because of the following sub-derivation:

simple_prop 
OPEN_PAREN prop CLOSE_PAREN // lookahead token appears
           prop_errors // lookahead token is inherited
           term Eq_OP term . 

** Conflict (shift/reduce) in state 78.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM Eq_OP Cons_TERM_OP CLOSE_PAREN
** The following explanations concentrate on token Zero_TERM.
** This state is reached from prop_toplevel after reading:

OPEN_PAREN term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
(?)

** In state 78, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

OPEN_PAREN term Eq_OP term CLOSE_PAREN COLON complex_type 
           term simple_term 
                . Zero_TERM 

** In state 78, looking ahead at Zero_TERM, reducing production
** term_errors -> OPEN_PAREN term 
** is permitted because of the following sub-derivation:

term Eq_OP term COLON complex_type 
term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term_errors // lookahead token is inherited
OPEN_PAREN term . 

** Conflict (shift/reduce) in state 76.
** Tokens involved: Or_PROP_OP Implies_PROP_OP And_PROP_OP
** The following explanations concentrate on token Or_PROP_OP.
** This state is reached from prop_toplevel after reading:

Forall_PROP VAR COLON complex_type DOT prop 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
(?)

** In state 76, looking ahead at Or_PROP_OP, shifting is permitted
** because of the following sub-derivation:

Forall_PROP VAR COLON complex_type DOT prop 
                                       prop . Or_PROP_OP prop 

** In state 76, looking ahead at Or_PROP_OP, reducing production
** prop -> Forall_PROP VAR COLON complex_type DOT prop 
** is permitted because of the following sub-derivation:

prop Or_PROP_OP prop // lookahead token appears
Forall_PROP VAR COLON complex_type DOT prop . 

** Conflict (shift/reduce) in state 69.
** Tokens involved: Or_PROP_OP Implies_PROP_OP And_PROP_OP
** The following explanations concentrate on token Or_PROP_OP.
** This state is reached from prop_toplevel after reading:

Exists_PROP VAR COLON complex_type DOT prop 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
(?)

** In state 69, looking ahead at Or_PROP_OP, shifting is permitted
** because of the following sub-derivation:

Exists_PROP VAR COLON complex_type DOT prop 
                                       prop . Or_PROP_OP prop 

** In state 69, looking ahead at Or_PROP_OP, reducing production
** prop -> Exists_PROP VAR COLON complex_type DOT prop 
** is permitted because of the following sub-derivation:

prop Or_PROP_OP prop // lookahead token appears
Exists_PROP VAR COLON complex_type DOT prop . 

** Conflict (shift/reduce) in state 51.
** Tokens involved: List_TYPE_OP CLOSE_PAREN Arrow_TYPE_OP
** The following explanations concentrate on token List_TYPE_OP.
** This state is reached from type_toplevel after reading:

OPEN_PAREN complex_type 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

type_toplevel 
complex_type EOF 
(?)

** In state 51, looking ahead at List_TYPE_OP, shifting is permitted
** because of the following sub-derivation:

simple_type 
OPEN_PAREN complex_type CLOSE_PAREN 
           complex_type . List_TYPE_OP 

** In state 51, looking ahead at List_TYPE_OP, reducing production
** type_errors -> OPEN_PAREN complex_type 
** is permitted because of the following sub-derivation:

complex_type List_TYPE_OP // lookahead token appears
type_errors // lookahead token is inherited
OPEN_PAREN complex_type . 

** Conflict (shift/reduce) in state 50.
** Token involved: List_TYPE_OP
** This state is reached from type_toplevel after reading:

Arrow_TYPE_OP complex_type 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

type_toplevel 
complex_type EOF 
(?)

** In state 50, looking ahead at List_TYPE_OP, shifting is permitted
** because of the following sub-derivation:

type_errors 
Arrow_TYPE_OP complex_type 
              complex_type . List_TYPE_OP 

** In state 50, looking ahead at List_TYPE_OP, reducing production
** type_errors -> Arrow_TYPE_OP complex_type 
** is permitted because of the following sub-derivation:

complex_type List_TYPE_OP // lookahead token appears
type_errors // lookahead token is inherited
Arrow_TYPE_OP complex_type . 

** Conflict (shift/reduce) in state 48.
** Token involved: List_TYPE_OP
** This state is reached from type_toplevel after reading:

complex_type Arrow_TYPE_OP complex_type 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

type_toplevel 
complex_type EOF 
(?)

** In state 48, looking ahead at List_TYPE_OP, reducing production
** complex_type -> complex_type Arrow_TYPE_OP complex_type 
** is permitted because of the following sub-derivation:

complex_type List_TYPE_OP // lookahead token appears
complex_type Arrow_TYPE_OP complex_type . 

** In state 48, looking ahead at List_TYPE_OP, shifting is permitted
** because of the following sub-derivation:

complex_type Arrow_TYPE_OP complex_type 
                           complex_type . List_TYPE_OP 

** Conflict (shift/reduce) in state 47.
** Token involved: List_TYPE_OP
** This state is reached from type_toplevel after reading:

complex_type Arrow_TYPE_OP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

type_toplevel 
complex_type EOF 
(?)

** In state 47, looking ahead at List_TYPE_OP, reducing production
** type_errors -> complex_type Arrow_TYPE_OP 
** is permitted because of the following sub-derivation:

complex_type List_TYPE_OP // lookahead token appears
type_errors // lookahead token is inherited
complex_type Arrow_TYPE_OP . 

** In state 47, looking ahead at List_TYPE_OP, shifting is permitted
** because of the following sub-derivation:

complex_type Arrow_TYPE_OP complex_type 
                           type_errors 
                           . List_TYPE_OP 

** Conflict (shift/reduce) in state 28.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM Cons_TERM_OP
** The following explanations concentrate on token Zero_TERM.
** This state is reached from prop_toplevel after reading:

Suc_TERM_OP term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
term Eq_OP term COLON complex_type 
(?)

** In state 28, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

Suc_TERM_OP term 
            term simple_term 
                 . Zero_TERM 

** In state 28, looking ahead at Zero_TERM, reducing production
** term -> Suc_TERM_OP term 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
Suc_TERM_OP term . 

** Conflict (shift/reduce) in state 27.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM Cons_TERM_OP CLOSE_PAREN
** The following explanations concentrate on token Zero_TERM.
** This state is reached from term_toplevel after reading:

OPEN_PAREN term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

term_toplevel 
term EOF 
(?)

** In state 27, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

simple_term 
OPEN_PAREN term CLOSE_PAREN 
           term simple_term 
                . Zero_TERM 

** In state 27, looking ahead at Zero_TERM, reducing production
** term_errors -> OPEN_PAREN term 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term_errors // lookahead token is inherited
OPEN_PAREN term . 

** Conflict (shift/reduce) in state 23.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM
** The following explanations concentrate on token Zero_TERM.
** This state is reached from prop_toplevel after reading:

term Cons_TERM_OP term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
term Eq_OP term COLON complex_type 
(?)

** In state 23, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

term Cons_TERM_OP term 
                  term simple_term 
                       . Zero_TERM 

** In state 23, looking ahead at Zero_TERM, reducing production
** term -> term Cons_TERM_OP term 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term Cons_TERM_OP term . 

** Conflict (shift/reduce) in state 22.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM
** The following explanations concentrate on token Zero_TERM.
** This state is reached from prop_toplevel after reading:

term Cons_TERM_OP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
term Eq_OP term COLON complex_type 
(?)

** In state 22, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

term Cons_TERM_OP term 
                  simple_term 
                  . Zero_TERM 

** In state 22, looking ahead at Zero_TERM, reducing production
** term_errors -> term Cons_TERM_OP 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term_errors // lookahead token is inherited
term Cons_TERM_OP . 

** Conflict (shift/reduce) in state 19.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM
** The following explanations concentrate on token Zero_TERM.
** This state is reached from prop_toplevel after reading:

Cons_TERM_OP term 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
term Eq_OP term COLON complex_type 
(?)

** In state 19, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

term_errors 
Cons_TERM_OP term 
             term simple_term 
                  . Zero_TERM 

** In state 19, looking ahead at Zero_TERM, reducing production
** term_errors -> Cons_TERM_OP term 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term_errors // lookahead token is inherited
Cons_TERM_OP term . 

** Conflict (shift/reduce) in state 12.
** Tokens involved: Zero_TERM VAR True_TERM OPEN_PAREN Nil_TERM False_TERM Cons_TERM_OP
** The following explanations concentrate on token Zero_TERM.
** This state is reached from prop_toplevel after reading:

Suc_TERM_OP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
term Eq_OP term COLON complex_type 
(?)

** In state 12, looking ahead at Zero_TERM, shifting is permitted
** because of the following sub-derivation:

Suc_TERM_OP term 
            simple_term 
            . Zero_TERM 

** In state 12, looking ahead at Zero_TERM, reducing production
** term_errors -> Suc_TERM_OP 
** is permitted because of the following sub-derivation:

term simple_term // lookahead token appears because simple_term can begin with Zero_TERM
term_errors // lookahead token is inherited
Suc_TERM_OP . 

** Conflict (reduce/reduce) in state 7.
** Tokens involved: Eq_OP CLOSE_PAREN
** The following explanations concentrate on token CLOSE_PAREN.
** This state is reached from prop_toplevel after reading:

OPEN_PAREN error 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prop_toplevel 
prop EOF 
(?)

** In state 7, looking ahead at CLOSE_PAREN, reducing production
** prop_errors -> error 
** is permitted because of the following sub-derivation:

simple_prop 
OPEN_PAREN prop CLOSE_PAREN // lookahead token appears
           prop_errors // lookahead token is inherited
           error . 

** In state 7, looking ahead at CLOSE_PAREN, reducing production
** term_errors -> error 
** is permitted because of the following sub-derivation:

term Eq_OP term COLON complex_type 
simple_term 
OPEN_PAREN term CLOSE_PAREN // lookahead token appears
           term_errors // lookahead token is inherited
           error . 
